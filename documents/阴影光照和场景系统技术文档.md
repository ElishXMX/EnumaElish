# EnumaElishå¼•æ“é˜´å½±å…‰ç…§å’Œåœºæ™¯ç³»ç»ŸæŠ€æœ¯æ–‡æ¡£

## ç›®å½•
- [1. ç³»ç»Ÿæ¶æ„æ¦‚è¿°](#1-ç³»ç»Ÿæ¶æ„æ¦‚è¿°)
- [2. ä»£ç çº§å®ç°ç»†èŠ‚](#2-ä»£ç çº§å®ç°ç»†èŠ‚)
- [3. å…³é”®ä»£ç ç¤ºä¾‹](#3-å…³é”®ä»£ç ç¤ºä¾‹)
- [4. æ€§èƒ½ä¼˜åŒ–è¯´æ˜](#4-æ€§èƒ½ä¼˜åŒ–è¯´æ˜)
- [5. æ•°å­¦å…¬å¼å’Œç®—æ³•](#5-æ•°å­¦å…¬å¼å’Œç®—æ³•)
- [6. ç³»ç»Ÿé›†æˆè¯´æ˜](#6-ç³»ç»Ÿé›†æˆè¯´æ˜)

---

## 1. ç³»ç»Ÿæ¶æ„æ¦‚è¿°

### 1.1 é˜´å½±å…‰ç…§ç³»ç»Ÿæ ¸å¿ƒç»„ä»¶

#### ç³»ç»Ÿæ¶æ„å›¾
```mermaid
flowchart TD
    A[RenderSystem] --> B[RenderPipeline]
    B --> C[DirectionalLightShadowPass]
    B --> D[MainCameraPass]
    C --> E[é˜´å½±è´´å›¾ç”Ÿæˆ]
    D --> F[ä¸»åœºæ™¯æ¸²æŸ“]
    D --> G[UIæ¸²æŸ“å­é€šé“]
    E --> H[æ·±åº¦ç¼“å†²åŒº]
    F --> I[å…‰ç…§è®¡ç®—]
    H --> I
    I --> J[æœ€ç»ˆæ¸²æŸ“ç»“æœ]
```

#### æ ¸å¿ƒç»„ä»¶è¯´æ˜

**1. æ¸²æŸ“ç³»ç»Ÿ (RenderSystem)**
- **ä½ç½®**: `engine/runtime/render/render_system.h`
- **èŒè´£**: æ•´ä½“æ¸²æŸ“ç³»ç»Ÿçš„åˆå§‹åŒ–å’Œç®¡ç†
- **å…³é”®åŠŸèƒ½**: Vulkanå®ä¾‹åˆ›å»ºã€èµ„æºç®¡ç†ã€å†…å®¹åŠ è½½

**2. æ¸²æŸ“ç®¡çº¿ (RenderPipeline)**
- **ä½ç½®**: `engine/runtime/render/render_pipeline.h`
- **èŒè´£**: ç»„ç»‡å’Œç®¡ç†æ‰€æœ‰æ¸²æŸ“é€šé“çš„æ‰§è¡Œé¡ºåº
- **æ¸²æŸ“æµç¨‹**: é˜´å½±æ¸²æŸ“ â†’ ä¸»ç›¸æœºæ¸²æŸ“ â†’ UIæ¸²æŸ“

**3. æ–¹å‘å…‰é˜´å½±é€šé“ (DirectionalLightShadowPass)**
- **ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.h`
- **èŒè´£**: ç”Ÿæˆæ–¹å‘å…‰çš„é˜´å½±è´´å›¾
- **è¾“å‡º**: 2048Ã—2048 32ä½æµ®ç‚¹æ·±åº¦çº¹ç†

**4. ä¸»ç›¸æœºæ¸²æŸ“é€šé“ (MainCameraPass)**
- **ä½ç½®**: `engine/runtime/render/passes/main_camera_pass.h`
- **èŒè´£**: ä¸»åœºæ™¯æ¸²æŸ“ï¼ŒåŒ…å«é˜´å½±è®¡ç®—å’ŒUIæ¸²æŸ“
- **å­é€šé“**: ä¸»æ¸²æŸ“å­é€šé“ + UIæ¸²æŸ“å­é€šé“

### 1.2 åœºæ™¯ç³»ç»Ÿç»„ç»‡ç»“æ„

#### åœºæ™¯ç®¡ç†æ¶æ„
```mermaid
classDiagram
    class RenderResource {
        +vector~RenderObject~ m_RenderObjects
        +addRenderObject()
        +createRenderObjectResource()
        +updateRenderObjectAnimationParams()
    }
    
    class RenderObject {
        +string name
        +string modelName
        +vector~Vertex~ vertices
        +vector~uint32_t~ indices
        +ModelAnimationParams animationParams
        +RHIBuffer* vertexBuffer
        +RHIBuffer* indexBuffer
    }
    
    class ModelAnimationParams {
        +vec3 position
        +vec3 rotation
        +vec3 scale
        +bool enableAnimation
        +bool isPlatform
    }
    
    RenderResource --> RenderObject
    RenderObject --> ModelAnimationParams
```

#### å…³é”®æ¨¡å—è¯´æ˜

**1. æ¸²æŸ“èµ„æºç®¡ç†å™¨ (RenderResource)**
- **ä½ç½®**: `engine/runtime/render/render_resource.h`
- **èŒè´£**: ç®¡ç†æ‰€æœ‰æ¸²æŸ“å¯¹è±¡å’ŒGPUèµ„æº
- **æ ¸å¿ƒæ•°æ®**: `std::vector<RenderObject> m_RenderObjects`

**2. æ¸²æŸ“å¯¹è±¡ (RenderObject)**
- **å®šä¹‰**: åŒ…å«å•ä¸ª3Dæ¨¡å‹çš„æ‰€æœ‰æ¸²æŸ“æ•°æ®
- **å†…å®¹**: é¡¶ç‚¹æ•°æ®ã€ç´¢å¼•æ•°æ®ã€çº¹ç†èµ„æºã€GPUç¼“å†²åŒº
- **åŠ¨ç”»**: æ”¯æŒä½ç½®ã€æ—‹è½¬ã€ç¼©æ”¾å˜æ¢

**3. åœºæ™¯åŠ è½½ç³»ç»Ÿ**
- **é…ç½®æ–‡ä»¶**: JSONæ ¼å¼åœºæ™¯æè¿°æ–‡ä»¶
- **æ”¯æŒæ ¼å¼**: OBJæ¨¡å‹æ–‡ä»¶ + PNG/JPGçº¹ç†æ–‡ä»¶
- **åŠ è½½æµç¨‹**: JSONè§£æ â†’ æ¨¡å‹åŠ è½½ â†’ çº¹ç†åˆ›å»º â†’ GPUèµ„æºåˆ†é…

---

## 2. ä»£ç çº§å®ç°ç»†èŠ‚

### 2.1 é˜´å½±è®¡ç®—ç®—æ³•å®ç°

#### é˜´å½±è´´å›¾ç”Ÿæˆæµç¨‹

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.cpp`

```cpp
/**
 * @brief æ‰§è¡Œé˜´å½±æ¸²æŸ“ç»˜åˆ¶
 * @details å®Œæ•´çš„é˜´å½±è´´å›¾ç”Ÿæˆæµç¨‹ï¼š
 *          1. å¼€å§‹é˜´å½±æ¸²æŸ“é€šé“ï¼Œæ¸…é™¤æ·±åº¦ç¼“å†²
 *          2. è®¾ç½®è§†å£å’Œè£å‰ªåŒºåŸŸä¸ºé˜´å½±è´´å›¾å°ºå¯¸
 *          3. ç»‘å®šé˜´å½±æ¸²æŸ“ç®¡çº¿
 *          4. æ›´æ–°uniform bufferï¼ˆå…‰æºçŸ©é˜µå’Œå®ä¾‹æ•°æ®ï¼‰
 *          5. ç»‘å®šæè¿°ç¬¦é›†
 *          6. æ¸²æŸ“æ‰€æœ‰æ¨¡å‹åˆ°æ·±åº¦ç¼“å†²
 *          7. ç»“æŸæ¸²æŸ“é€šé“
 */
void DirectionalLightShadowPass::draw()
{
    // 1. å¼€å§‹æ¸²æŸ“é€šé“
    RHIRenderPassBeginInfo render_pass_begin{};
    render_pass_begin.renderPass = m_render_pass;
    render_pass_begin.framebuffer = m_framebuffer;
    render_pass_begin.renderArea.extent.width = SHADOW_MAP_SIZE;  // 2048
    render_pass_begin.renderArea.extent.height = SHADOW_MAP_SIZE; // 2048
    
    // æ·±åº¦é™„ä»¶æ¸…é™¤å€¼
    RHIClearValue clear_values[1];
    clear_values[0].depthStencil = {1.0f, 0}; // æ·±åº¦å€¼æ¸…é™¤ä¸º1.0ï¼ˆæœ€è¿œï¼‰
    
    // 2. æ¸²æŸ“æ‰€æœ‰æ¨¡å‹åˆ°æ·±åº¦ç¼“å†²
    drawModel();
}
```

#### å…‰æºæŠ•å½±çŸ©é˜µè®¡ç®—

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.cpp:875-895`

```cpp
/**
 * @brief æ›´æ–°å…‰æºçš„æŠ•å½±è§†å›¾çŸ©é˜µ
 * @param render_resource æ¸²æŸ“èµ„æºç®¡ç†å™¨
 */
void DirectionalLightShadowPass::updateLightMatrix(std::shared_ptr<RenderResource> render_resource)
{
    // å›ºå®šçš„å…‰æºæ–¹å‘ï¼ˆä»ä¸Šæ–¹æ–œå‘ä¸‹ç…§å°„ï¼‰
    glm::vec3 lightDirection = glm::vec3(-0.5f, -1.0f, -0.3f);
    
    // å…‰æºä½ç½®ï¼ˆè·ç¦»åœºæ™¯ä¸­å¿ƒ50ä¸ªå•ä½ï¼‰
    glm::vec3 lightPosition = -lightDirection * 50.0f;
    
    // å…‰æºå‚æ•°éªŒè¯å’Œè°ƒè¯•è¾“å‡º
    LOG_INFO("Light Direction: ({:.2f}, {:.2f}, {:.2f})", 
             lightDirection.x, lightDirection.y, lightDirection.z);
    LOG_INFO("Light Position: ({:.2f}, {:.2f}, {:.2f})", 
             lightPosition.x, lightPosition.y, lightPosition.z);
    
    // åˆ›å»ºå…‰æºçš„è§†å›¾çŸ©é˜µï¼ˆå…‰æºçœ‹å‘åœºæ™¯ä¸­å¿ƒï¼‰
    glm::mat4 lightView = glm::lookAt(lightPosition, 
                                      glm::vec3(0.0f, 0.0f, 0.0f), 
                                      glm::vec3(0.0f, 1.0f, 0.0f));
    
    // åˆ›å»ºæ­£äº¤æŠ•å½±çŸ©é˜µï¼ˆæ‰©å¤§æŠ•å½±èŒƒå›´ä»¥ç¡®ä¿å®Œæ•´è¦†ç›–åœºæ™¯ï¼‰
    float ortho_size = 50.0f;  // æ­£äº¤æŠ•å½±èŒƒå›´ï¼ˆä»30.0få¢å¤§åˆ°50.0fï¼‰
    float near_plane = 0.1f;   // è¿‘å¹³é¢ï¼ˆä»1.0fè°ƒæ•´ä¸º0.1fï¼‰
    float far_plane = 150.0f;  // è¿œå¹³é¢ï¼ˆä»100.0fæ‰©å¤§åˆ°150.0fï¼‰
    
    glm::mat4 lightProjection = glm::ortho(-ortho_size, ortho_size, 
                                           -ortho_size, ortho_size, 
                                           near_plane, far_plane);
    
    // æŠ•å½±å‚æ•°éªŒè¯å’Œè°ƒè¯•è¾“å‡º
    LOG_INFO("Projection Parameters - Size: {:.1f}, Near: {:.1f}, Far: {:.1f}", 
             ortho_size, near_plane, far_plane);
    
    // è®¡ç®—æœ€ç»ˆçš„å…‰æºæŠ•å½±è§†å›¾çŸ©é˜µ
    m_light_proj_view_matrix = lightProjection * lightView;
    
    // çŸ©é˜µæœ‰æ•ˆæ€§æ£€æŸ¥
    float determinant = glm::determinant(m_light_proj_view_matrix);
    if (abs(determinant) < 1e-6) {
        LOG_ERROR("Light projection-view matrix is singular! Determinant: {:.6f}", determinant);
    } else {
        LOG_DEBUG("Light projection-view matrix determinant: {:.6f}", determinant);
    }
}
```

### 2.2 å…‰ç…§æ¨¡å‹æ•°å­¦å…¬å¼å’Œç€è‰²å™¨ä»£ç 

#### PBRå…‰ç…§æ¨¡å‹å®ç°

**æ–‡ä»¶ä½ç½®**: `engine/runtime/shader/include/mesh_lighting.h`

**æ ¸å¿ƒBRDFå‡½æ•°**:
```glsl
/**
 * @brief åŸºäºç‰©ç†çš„åŒå‘åå°„åˆ†å¸ƒå‡½æ•°(BRDF)
 * @param L å…‰æºæ–¹å‘å‘é‡
 * @param V è§†çº¿æ–¹å‘å‘é‡  
 * @param N è¡¨é¢æ³•çº¿å‘é‡
 * @param F0 è²æ¶…å°”åå°„ç‡
 * @param basecolor åŸºç¡€é¢œè‰²
 * @param metallic é‡‘å±åº¦
 * @param roughness ç²—ç³™åº¦
 * @return å…‰ç…§è´¡çŒ®å€¼
 */
highp vec3 BRDF(highp vec3 L, highp vec3 V, highp vec3 N, 
                highp vec3 F0, highp vec3 basecolor, 
                highp float metallic, highp float roughness)
{
    // è®¡ç®—åŠè§’å‘é‡
    highp vec3 H = normalize(V + L);
    
    // è®¡ç®—å„ç§ç‚¹ç§¯
    highp float dotNV = clamp(dot(N, V), 0.0, 1.0);
    highp float dotNL = clamp(dot(N, L), 0.0, 1.0);
    highp float dotNH = clamp(dot(N, H), 0.0, 1.0);
    
    // Dé¡¹ï¼šæ³•çº¿åˆ†å¸ƒå‡½æ•°ï¼ˆGGXåˆ†å¸ƒï¼‰
    highp float D = D_GGX(dotNH, roughness);
    
    // Gé¡¹ï¼šå‡ ä½•é®è”½å‡½æ•°ï¼ˆSmith Gå‡½æ•°ï¼‰
    highp float G = G_SchlicksmithGGX(dotNL, dotNV, roughness);
    
    // Fé¡¹ï¼šè²æ¶…å°”åå°„å‡½æ•°ï¼ˆSchlickè¿‘ä¼¼ï¼‰
    highp vec3 F = F_Schlick(dotNV, F0);
    
    // è®¡ç®—é•œé¢åå°„é¡¹
    highp vec3 spec = D * F * G / (4.0 * dotNL * dotNV + 0.001);
    
    // è®¡ç®—æ¼«åå°„é¡¹
    highp vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);
    
    return (kD * basecolor / PI + (1.0 - kD) * spec);
}
```

**GGXæ³•çº¿åˆ†å¸ƒå‡½æ•°**:
```glsl
/**
 * @brief GGX/Trowbridge-Reitzæ³•çº¿åˆ†å¸ƒå‡½æ•°
 * @param dotNH æ³•çº¿ä¸åŠè§’å‘é‡çš„ç‚¹ç§¯
 * @param roughness è¡¨é¢ç²—ç³™åº¦
 * @return æ³•çº¿åˆ†å¸ƒæ¦‚ç‡å¯†åº¦
 */
highp float D_GGX(highp float dotNH, highp float roughness)
{
    highp float alpha = roughness * roughness;
    highp float alpha2 = alpha * alpha;
    highp float denom = dotNH * dotNH * (alpha2 - 1.0) + 1.0;
    return (alpha2) / (PI * denom * denom);
}
```

**Smithå‡ ä½•é®è”½å‡½æ•°**:
```glsl
/**
 * @brief Smithå‡ ä½•é®è”½å‡½æ•°ï¼ˆGGXåˆ†å¸ƒï¼‰
 * @param dotNL æ³•çº¿ä¸å…‰æºæ–¹å‘çš„ç‚¹ç§¯
 * @param dotNV æ³•çº¿ä¸è§†çº¿æ–¹å‘çš„ç‚¹ç§¯
 * @param roughness è¡¨é¢ç²—ç³™åº¦
 * @return å‡ ä½•é®è”½å› å­
 */
highp float G_SchlicksmithGGX(highp float dotNL, highp float dotNV, highp float roughness)
{
    highp float r = (roughness + 1.0);
    highp float k = (r * r) / 8.0;
    highp float GL = dotNL / (dotNL * (1.0 - k) + k);
    highp float GV = dotNV / (dotNV * (1.0 - k) + k);
    return GL * GV;
}
```

#### é˜´å½±è®¡ç®—ç€è‰²å™¨å®ç°

**æ–‡ä»¶ä½ç½®**: `engine/runtime/shader/include/mesh_lighting.inl:85-120`

```glsl
// æ–¹å‘å…‰é˜´å½±è®¡ç®—
{
    highp vec3 L = normalize(scene_directional_light.direction);
    highp float NoL = min(dot(N, L), 1.0);
    
    if (NoL > 0.0)
    {
        highp float shadow;
        {
            // å°†ä¸–ç•Œåæ ‡è½¬æ¢åˆ°å…‰æºè£å‰ªç©ºé—´
            highp vec4 position_clip = directional_light_proj_view * vec4(in_world_position, 1.0);
            highp vec3 position_ndc = position_clip.xyz / position_clip.w;
            
            // è½¬æ¢åˆ°çº¹ç†åæ ‡[0,1]
            highp vec2 uv = ndcxy_to_uv(position_ndc.xy);
            
            // é‡‡æ ·é˜´å½±è´´å›¾æ·±åº¦å€¼
            highp float closest_depth = texture(directional_light_shadow, uv).r + 0.000075;
            highp float current_depth = position_ndc.z;
            
            // æ·±åº¦æ¯”è¾ƒç¡®å®šé˜´å½±
            shadow = (closest_depth >= current_depth) ? 1.0f : -1.0f;
        }
        
        if (shadow > 0.0f)
        {
            // è®¡ç®—å…‰ç…§è´¡çŒ®
            highp vec3 En = scene_directional_light.color * NoL;
            Lo += BRDF(L, V, N, F0, basecolor, metallic, roughness) * En;
        }
    }
}
```

### 2.3 åœºæ™¯ç®¡ç†æ ¸å¿ƒæ•°æ®ç»“æ„

#### æ¸²æŸ“å¯¹è±¡ç»“æ„å®šä¹‰

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/render_resource.h:160-185`

```cpp
/**
 * @brief æ¸²æŸ“ä¸€ä¸ªæ¨¡å‹éœ€è¦çš„æ‰€æœ‰RHIèµ„æº
 */
struct RenderObject {
    std::string name;                    // æ¨¡å‹åç§°
    std::string modelName;               // æ¨¡å‹æ ‡è¯†åç§°ï¼Œç”¨äºè¯†åˆ«å’Œç®¡ç†
    std::vector<Vertex> vertices;        // é¡¶ç‚¹æ•°æ®
    std::vector<uint32_t> indices;       // ç´¢å¼•æ•°æ®
    
    // GPUç¼“å†²åŒºèµ„æº
    RHIBuffer* vertexBuffer;             // é¡¶ç‚¹ç¼“å†²åŒº
    RHIDeviceMemory* vertexBufferMemory; // é¡¶ç‚¹ç¼“å†²åŒºå†…å­˜
    RHIBuffer* indexBuffer;              // ç´¢å¼•ç¼“å†²åŒº
    RHIDeviceMemory* indexBufferMemory;  // ç´¢å¼•ç¼“å†²åŒºå†…å­˜
    
    // çº¹ç†èµ„æº
    std::vector<RHIImage*> textureImages;           // çº¹ç†å›¾åƒ
    std::vector<RHIDeviceMemory*> textureImageMemorys; // çº¹ç†å†…å­˜
    std::vector<RHIImageView*> textureImageViews;   // çº¹ç†è§†å›¾
    std::vector<RHISampler*> textureSamplers;       // çº¹ç†é‡‡æ ·å™¨
    
    // æè¿°ç¬¦èµ„æº
    RHIDescriptorPool* descriptorPool;              // æè¿°ç¬¦æ± 
    std::vector<RHIDescriptorSet*> descriptorSets;  // æè¿°ç¬¦é›†åˆ
    RHIDescriptorSet* textureDescriptorSet;         // çº¹ç†æè¿°ç¬¦é›†åˆ
    
    // åŠ¨ç”»å‚æ•°
    ModelAnimationParams animationParams;           // æ¯ä¸ªæ¨¡å‹çš„ç‹¬ç«‹åŠ¨ç”»å‚æ•°
};
```

#### é¡¶ç‚¹æ•°æ®ç»“æ„

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/render_resource.h:18-65`

```cpp
/**
 * @brief é¡¶ç‚¹æ•°æ®ç»“æ„
 */
struct Vertex {
    glm::vec3 pos;      // ä½ç½®åæ ‡
    glm::vec3 color;    // é¡¶ç‚¹é¢œè‰²
    glm::vec2 texCoord; // çº¹ç†åæ ‡
    glm::vec3 normal;   // æ³•çº¿å‘é‡
    
    /**
     * @brief è·å–Vulkané¡¶ç‚¹è¾“å…¥ç»‘å®šæè¿°
     */
    static RHIVertexInputBindingDescription getBindingDescription() {
        RHIVertexInputBindingDescription bindingDescription{};
        bindingDescription.binding = 0;
        bindingDescription.stride = sizeof(Vertex);
        bindingDescription.inputRate = RHI_VERTEX_INPUT_RATE_VERTEX;
        return bindingDescription;
    }
    
    /**
     * @brief è·å–Vulkané¡¶ç‚¹å±æ€§æè¿°æ•°ç»„
     */
    static std::vector<RHIVertexInputAttributeDescription> getAttributeDescriptions() {
        std::vector<RHIVertexInputAttributeDescription> attributeDescriptions(4);
        
        // ä½ç½®å±æ€§
        attributeDescriptions[0].binding = 0;
        attributeDescriptions[0].location = 0;
        attributeDescriptions[0].format = RHI_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[0].offset = offsetof(Vertex, pos);
        
        // é¢œè‰²å±æ€§
        attributeDescriptions[1].binding = 0;
        attributeDescriptions[1].location = 1;
        attributeDescriptions[1].format = RHI_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[1].offset = offsetof(Vertex, color);
        
        // çº¹ç†åæ ‡å±æ€§
        attributeDescriptions[2].binding = 0;
        attributeDescriptions[2].location = 2;
        attributeDescriptions[2].format = RHI_FORMAT_R32G32_SFLOAT;
        attributeDescriptions[2].offset = offsetof(Vertex, texCoord);
        
        // æ³•çº¿å±æ€§
        attributeDescriptions[3].binding = 0;
        attributeDescriptions[3].location = 3;
        attributeDescriptions[3].format = RHI_FORMAT_R32G32B32_SFLOAT;
        attributeDescriptions[3].offset = offsetof(Vertex, normal);
        
        return attributeDescriptions;
    }
};
```

---

## 3. å…³é”®ä»£ç ç¤ºä¾‹

### 3.1 å®Œæ•´çš„é˜´å½±ç”Ÿæˆä»£ç ç‰‡æ®µ

#### é˜´å½±è´´å›¾èµ„æºåˆ›å»º

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.cpp:180-230`

```cpp
/**
 * @brief è®¾ç½®é˜´å½±æ¸²æŸ“é™„ä»¶
 * @details åˆ›å»ºé«˜è´¨é‡é˜´å½±æ·±åº¦å›¾åƒå’Œç›¸å…³èµ„æºï¼š
 *          1. ğŸ–¼ï¸ åˆ›å»ºé«˜ç²¾åº¦é˜´å½±æ·±åº¦å›¾åƒ
 *          2. ğŸ‘ï¸ åˆ›å»ºæ·±åº¦å›¾åƒè§†å›¾
 *          3. ğŸ” æ·±åº¦é‡‡æ ·å™¨é…ç½®ï¼ˆå¯é€‰ï¼‰
 */
void DirectionalLightShadowPass::setupAttachments()
{
    std::shared_ptr<RHI> rhi = g_runtime_global_context.m_render_system->getRHI();
    
    // ğŸ–¼ï¸ åˆ›å»ºé«˜ç²¾åº¦é˜´å½±æ·±åº¦å›¾åƒ
    // ä½¿ç”¨32ä½æµ®ç‚¹æ ¼å¼ç¡®ä¿æœ€ä½³æ·±åº¦ç²¾åº¦å’Œé˜´å½±è´¨é‡
    rhi->createImage(
        SHADOW_MAP_SIZE, SHADOW_MAP_SIZE,           // 2048x2048åˆ†è¾¨ç‡
        RHI_FORMAT_D32_SFLOAT,                      // 32ä½æµ®ç‚¹æ·±åº¦æ ¼å¼
        RHI_IMAGE_TILING_OPTIMAL,                   // æœ€ä¼˜å†…å­˜å¸ƒå±€
        RHI_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT | RHI_IMAGE_USAGE_SAMPLED_BIT, // æ·±åº¦é™„ä»¶+é‡‡æ ·
        RHI_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,       // GPUæœ¬åœ°å†…å­˜
        m_shadow_map_image,
        m_shadow_map_image_memory,
        0, 1, 1
    );
    
    // ğŸ‘ï¸ åˆ›å»ºæ·±åº¦å›¾åƒè§†å›¾
    rhi->createImageView(
        m_shadow_map_image,
        RHI_FORMAT_D32_SFLOAT,
        RHI_IMAGE_ASPECT_DEPTH_BIT,
        RHI_IMAGE_VIEW_TYPE_2D,
        1, 1, 0, 0,
        m_shadow_map_image_view
    );
    
    // ğŸ” åˆ›å»ºé˜´å½±è´´å›¾é‡‡æ ·å™¨ï¼ˆç”¨äºç€è‰²å™¨é‡‡æ ·ï¼‰
    RHISamplerCreateInfo sampler_info{};
    sampler_info.sType = RHI_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
    sampler_info.magFilter = RHI_FILTER_LINEAR;          // çº¿æ€§è¿‡æ»¤å‡å°‘é”¯é½¿
    sampler_info.minFilter = RHI_FILTER_LINEAR;
    sampler_info.addressModeU = RHI_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
    sampler_info.addressModeV = RHI_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
    sampler_info.addressModeW = RHI_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
    sampler_info.borderColor = RHI_BORDER_COLOR_FLOAT_OPAQUE_WHITE; // è¾¹ç•Œä¸ºç™½è‰²ï¼ˆæ— é˜´å½±ï¼‰
    sampler_info.compareEnable = RHI_FALSE;              // ç¦ç”¨ç¡¬ä»¶PCF
    sampler_info.compareOp = RHI_COMPARE_OP_LESS_OR_EQUAL;
    
    rhi->createSampler(&sampler_info, m_shadow_map_sampler);
}
```

#### é˜´å½±æ¸²æŸ“ç®¡çº¿åˆ›å»º

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.cpp:499-580`

```cpp
/**
 * @brief è®¾ç½®é˜´å½±æ¸²æŸ“ç®¡çº¿
 * @details åˆ›å»ºä¸“ç”¨äºé˜´å½±ç”Ÿæˆçš„å›¾å½¢ç®¡çº¿ï¼š
 *          - é¡¶ç‚¹ç€è‰²å™¨ï¼šç®€åŒ–çš„å˜æ¢é€»è¾‘
 *          - ç‰‡æ®µç€è‰²å™¨ï¼šç©ºå®ç°ï¼ˆåªéœ€æ·±åº¦å†™å…¥ï¼‰
 *          - æ·±åº¦æµ‹è¯•ï¼šå¯ç”¨ï¼Œç”¨äºæ·±åº¦ç¼“å†²å†™å…¥
 *          - é¢œè‰²æ··åˆï¼šç¦ç”¨ï¼ˆæ— é¢œè‰²è¾“å‡ºï¼‰
 */
void DirectionalLightShadowPass::setupPipelines()
{
    std::shared_ptr<RHI> rhi = g_runtime_global_context.m_render_system->getRHI();
    
    // åŠ è½½é˜´å½±æ¸²æŸ“ç€è‰²å™¨
    RHIShader* vert_shader_module = rhi->createShaderModule(SHADOW_VERT);
    RHIShader* frag_shader_module = rhi->createShaderModule(SHADOW_FRAG);
    
    // é…ç½®ç€è‰²å™¨é˜¶æ®µ
    RHIPipelineShaderStageCreateInfo shader_stages[2];
    shader_stages[0].sType = RHI_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shader_stages[0].stage = RHI_SHADER_STAGE_VERTEX_BIT;
    shader_stages[0].module = vert_shader_module;
    shader_stages[0].pName = "main";
    
    shader_stages[1].sType = RHI_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
    shader_stages[1].stage = RHI_SHADER_STAGE_FRAGMENT_BIT;
    shader_stages[1].module = frag_shader_module;
    shader_stages[1].pName = "main";
    
    // é¡¶ç‚¹è¾“å…¥çŠ¶æ€ï¼ˆåŒ¹é…Vertexç»“æ„ï¼‰
    RHIVertexInputBindingDescription binding_description{};
    binding_description.binding = 0;
    binding_description.stride = sizeof(float) * 11; // position(3) + normal(3) + color(3) + texCoord(2)
    binding_description.inputRate = RHI_VERTEX_INPUT_RATE_VERTEX;
    
    // é…ç½®é¡¶ç‚¹å±æ€§ï¼ˆåªéœ€è¦ä½ç½®ä¿¡æ¯ç”¨äºæ·±åº¦è®¡ç®—ï¼‰
    RHIVertexInputAttributeDescription attribute_descriptions[1];
    attribute_descriptions[0].binding = 0;
    attribute_descriptions[0].location = 0;
    attribute_descriptions[0].format = RHI_FORMAT_R32G32B32_SFLOAT;
    attribute_descriptions[0].offset = 0;
    
    RHIPipelineVertexInputStateCreateInfo vertex_input_info{};
    vertex_input_info.sType = RHI_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
    vertex_input_info.vertexBindingDescriptionCount = 1;
    vertex_input_info.pVertexBindingDescriptions = &binding_description;
    vertex_input_info.vertexAttributeDescriptionCount = 1;
    vertex_input_info.pVertexAttributeDescriptions = attribute_descriptions;
    
    // è¾“å…¥è£…é…çŠ¶æ€
    RHIPipelineInputAssemblyStateCreateInfo input_assembly{};
    input_assembly.sType = RHI_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
    input_assembly.topology = RHI_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
    input_assembly.primitiveRestartEnable = RHI_FALSE;
    
    // æ·±åº¦æ¨¡æ¿çŠ¶æ€ï¼ˆå¯ç”¨æ·±åº¦æµ‹è¯•å’Œå†™å…¥ï¼‰
    RHIPipelineDepthStencilStateCreateInfo depth_stencil{};
    depth_stencil.sType = RHI_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO;
    depth_stencil.depthTestEnable = RHI_TRUE;
    depth_stencil.depthWriteEnable = RHI_TRUE;
    depth_stencil.depthCompareOp = RHI_COMPARE_OP_LESS_OR_EQUAL; // ä¿®æ­£æ·±åº¦æ¯”è¾ƒæ“ä½œ
    depth_stencil.depthBoundsTestEnable = RHI_FALSE;
    depth_stencil.stencilTestEnable = RHI_FALSE;
    
    // å…‰æ …åŒ–çŠ¶æ€
    RHIPipelineRasterizationStateCreateInfo rasterizer{};
    rasterizer.sType = RHI_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
    rasterizer.depthClampEnable = RHI_FALSE;
    rasterizer.rasterizerDiscardEnable = RHI_FALSE;
    rasterizer.polygonMode = RHI_POLYGON_MODE_FILL;
    rasterizer.lineWidth = 1.0f;
    rasterizer.cullMode = RHI_CULL_MODE_BACK_BIT;  // èƒŒé¢å‰”é™¤
    rasterizer.frontFace = RHI_FRONT_FACE_COUNTER_CLOCKWISE;
    rasterizer.depthBiasEnable = RHI_FALSE;
    
    // åˆ›å»ºå›¾å½¢ç®¡çº¿
    RHIGraphicsPipelineCreateInfo pipeline_info{};
    pipeline_info.sType = RHI_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO;
    pipeline_info.stageCount = 2;
    pipeline_info.pStages = shader_stages;
    pipeline_info.pVertexInputState = &vertex_input_info;
    pipeline_info.pInputAssemblyState = &input_assembly;
    pipeline_info.pDepthStencilState = &depth_stencil;
    pipeline_info.pRasterizationState = &rasterizer;
    pipeline_info.layout = m_pipeline_layout;
    pipeline_info.renderPass = m_render_pass;
    pipeline_info.subpass = 0;
    
    rhi->createGraphicsPipelines(RHI_NULL_HANDLE, 1, &pipeline_info, m_render_pipeline);
    
    // æ¸…ç†ç€è‰²å™¨æ¨¡å—
    rhi->destroyShaderModule(vert_shader_module);
    rhi->destroyShaderModule(frag_shader_module);
}
```

### 3.2 å…‰ç…§è®¡ç®—å®ç°ä»£ç 

#### PCFè½¯é˜´å½±å®ç°

**æ–‡ä»¶ä½ç½®**: `engine/runtime/shader/glsl/mesh.frag:30-65`

```glsl
/**
 * @brief è®¡ç®—é˜´å½±å› å­ï¼ˆä½¿ç”¨PCFè½¯é˜´å½±ï¼‰
 * @param fragPosLightSpace ç‰‡æ®µåœ¨å…‰ç©ºé—´ä¸­çš„åæ ‡
 * @return é˜´å½±å› å­ï¼ˆ0.0=å®Œå…¨é˜´å½±ï¼Œ1.0=å®Œå…¨å…‰ç…§ï¼‰
 */
float calculateShadow(vec4 fragPosLightSpace)
{
    // é€è§†é™¤æ³•ï¼Œè½¬æ¢åˆ°NDCåæ ‡[-1,1]
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    
    // è½¬æ¢åˆ°çº¹ç†åæ ‡[0,1]
    projCoords = projCoords * 0.5 + 0.5;
    
    // æ£€æŸ¥æ˜¯å¦åœ¨é˜´å½±è´´å›¾èŒƒå›´å†…
    if (projCoords.z > 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || 
        projCoords.y < 0.0 || projCoords.y > 1.0) {
        return 1.0; // è¶…å‡ºèŒƒå›´ï¼Œè®¤ä¸ºæ— é˜´å½±
    }
    
    // è·å–å½“å‰ç‰‡æ®µåœ¨å…‰ç©ºé—´ä¸­çš„æ·±åº¦
    float currentDepth = projCoords.z;
    
    // æ·»åŠ åç½®ä»¥å‡å°‘é˜´å½±å¤±çœŸï¼ˆshadow acneï¼‰
    float bias = 0.005;
    
    // PCF (Percentage Closer Filtering) è½¯é˜´å½±å®ç°
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(directional_light_shadow, 0);
    
    // 3x3 PCFé‡‡æ ·
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            float pcfDepth = texture(directional_light_shadow, projCoords.xy + vec2(x, y) * texelSize).r;
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
        }
    }
    shadow /= 9.0; // å¹³å‡9ä¸ªé‡‡æ ·ç‚¹
    
    // è¿”å›å…‰ç…§å› å­ï¼ˆ1.0 - shadowï¼‰
    return 1.0 - shadow;
}
```

#### ä¸»æ¸²æŸ“ç€è‰²å™¨å…‰ç…§è®¡ç®—

**æ–‡ä»¶ä½ç½®**: `engine/runtime/shader/glsl/PBR.frag:240-290`

```glsl
void main()
{
    // é‡‡æ ·æè´¨å±æ€§
    vec3 base_color = texture(sampler1, fragTexCoord).rgb;
    float metallic = saturate(texture(sampler2, fragTexCoord).r);
    float roughness = saturate(texture(sampler3, fragTexCoord).r);
    vec3 normal = calcNormal(texture(sampler4, fragTexCoord).rgb);
    vec3 ambient_occlution = texture(sampler5, fragTexCoord).rgb;
    
    roughness = max(0.01, roughness); // é˜²æ­¢é™¤é›¶
    
    vec3 N = normal;
    vec3 V = normalize(view.camera_position.xyz - fragPosition);
    float NdotV = saturate(dot(N, V));
    
    // ç›´æ¥å…‰ç…§è®¡ç®—
    vec3 direct_lighting = vec3(0.0);
    vec3 diffuse_color = base_color.rgb * (1.0 - metallic);
    
    // æ–¹å‘å…‰è®¡ç®—
    for (uint i = 0u; i < DIRECTIONAL_LIGHTS; ++i)
    {
        vec3 L = get_directional_light_direction(i);
        vec3 H = normalize(V + L);
        
        float LdotH = saturate(dot(L, H));
        float NdotH = saturate(dot(N, H));
        float NdotL = saturate(dot(N, L));
        
        // PBRå…‰ç…§è®¡ç®—
        float F90 = saturate(50.0 * F0.r);
        vec3 F = F_Schlick(F0, F90, LdotH);
        float Vis = V_SmithGGXCorrelated(NdotV, NdotL, roughness);
        float D = D_GGX(NdotH, roughness);
        vec3 Fr = F * D * Vis;
        
        float Fd = Fr_DisneyDiffuse(NdotV, NdotL, LdotH, roughness);
        
        vec3 direct_diffuse = diffuse_color * (vec3(1.0) - F) * Fd;
        vec3 direct_specular = Fr;
        
        // é˜´å½±è®¡ç®—
        float shadow = 1.0;
        {
            vec4 position_clip = ubo.directional_light_proj_view * vec4(fragPosition, 1.0);
            vec3 position_ndc = position_clip.xyz / position_clip.w;
            
            // è½¬æ¢åˆ°çº¹ç†åæ ‡
            vec2 uv = position_ndc.xy * 0.5 + 0.5;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨é˜´å½±è´´å›¾èŒƒå›´å†…
            if (uv.x >= 0.0 && uv.x <= 1.0 && uv.y >= 0.0 && uv.y <= 1.0) {
                float closest_depth = texture(directional_light_shadow, uv).r + 0.000075;
                float current_depth = position_ndc.z;
                
                shadow = (closest_depth >= current_depth) ? 1.0 : 0.0;
            }
        }
        
        direct_lighting += apply_directional_light(i, N) * (direct_diffuse + direct_specular) * shadow;
    }
    
    // é—´æ¥å…‰ç…§
    vec3 indirect_lighting = diffuse_color.rgb / PI * ambient_occlution;
    
    // ç¯å¢ƒåå°„
    vec3 specular = ComputeF0(0.5, base_color, metallic);
    vec3 reflection_brdf = EnvBRDFApprox(specular, roughness, NdotV);
    vec3 R = reflect(-V, N);
    float mip = compute_reflection_mip_from_roughness(roughness, SKY_MAXMIPS);
    vec3 reflection_L = textureLod(skycube, R, mip).rgb * 10.0;
    vec3 reflection_color = reflection_L * reflection_brdf;
    
    // æœ€ç»ˆé¢œè‰²åˆæˆ
    vec3 final_color = direct_lighting + indirect_lighting * 0.3 + reflection_color;
    
    // ä¼½é©¬æ ¡æ­£
    final_color = pow(final_color, vec3(0.4545));
    
    outColor = vec4(final_color, 1.0);
}
```

### 3.3 åœºæ™¯åŠ è½½å’Œç®¡ç†ç¤ºä¾‹ä»£ç 

#### JSONé…ç½®æ–‡ä»¶è§£æ

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/render_system.cpp:46-100`

```cpp
/**
 * @brief ä»JSONé…ç½®æ–‡ä»¶åŠ è½½èµ„æºè·¯å¾„
 * @param model_paths è¾“å‡ºçš„æ¨¡å‹è·¯å¾„æ˜ å°„
 * @param model_texture_map è¾“å‡ºçš„æ¨¡å‹çº¹ç†æ˜ å°„
 * @param model_animation_params è¾“å‡ºçš„åŠ¨ç”»å‚æ•°æ˜ å°„
 */
void RenderSystem::loadResourcesFromJson(
    std::unordered_map<std::string, std::string>& model_paths,
    std::unordered_map<std::string, std::vector<std::string>>& model_texture_map,
    std::unordered_map<std::string, ModelAnimationParams>& model_animation_params)
{
    // è¯»å–JSONé…ç½®æ–‡ä»¶
    std::ifstream config_file("engine/content/levels/levels1.json");
    if (!config_file.is_open()) {
        LOG_ERROR("Failed to open levels1.json");
        return;
    }
    
    std::string json_content((std::istreambuf_iterator<char>(config_file)),
                            std::istreambuf_iterator<char>());
    config_file.close();
    
    // è§£æJSON
    std::string json_error;
    json11::Json json_data = json11::Json::parse(json_content, json_error);
    
    if (!json_error.empty()) {
        LOG_ERROR("JSON parse error: {}", json_error);
        return;
    }
    
    // éå†åœºæ™¯æ•°æ®
    auto scenes = json_data["scenes"].array_items();
    for (const auto& scene : scenes) {
        auto objects = scene["objects"].array_items();
        
        for (const auto& object : objects) {
            std::string model_name = object["model_name"].string_value();
            std::string model_path = object["model_path"].string_value();
            
            // å­˜å‚¨æ¨¡å‹è·¯å¾„
            model_paths[model_name] = model_path;
            
            // è§£æçº¹ç†è·¯å¾„
            std::vector<std::string> texture_paths;
            auto textures = object["model_texture_map"].array_items();
            for (const auto& texture : textures) {
                texture_paths.push_back(texture.string_value());
            }
            model_texture_map[model_name] = texture_paths;
            
            // è§£æåŠ¨ç”»å‚æ•°ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (object["animation_params"].is_object()) {
                ModelAnimationParams params;
                auto anim = object["animation_params"];
                
                // è§£æä½ç½®
                if (anim["position"].is_array()) {
                    auto pos = anim["position"].array_items();
                    params.position = glm::vec3(pos[0].number_value(), 
                                               pos[1].number_value(), 
                                               pos[2].number_value());
                }
                
                // è§£ææ—‹è½¬
                if (anim["rotation"].is_array()) {
                    auto rot = anim["rotation"].array_items();
                    params.rotation = glm::vec3(rot[0].number_value(), 
                                               rot[1].number_value(), 
                                               rot[2].number_value());
                }
                
                // è§£æç¼©æ”¾
                if (anim["scale"].is_array()) {
                    auto scale = anim["scale"].array_items();
                    params.scale = glm::vec3(scale[0].number_value(), 
                                            scale[1].number_value(), 
                                            scale[2].number_value());
                }
                
                params.enableAnimation = anim["enable_animation"].bool_value();
                params.rotationSpeed = anim["rotation_speed"].number_value();
                
                model_animation_params[model_name] = params;
            }
        }
    }
}
```

#### æ‰¹é‡æ¨¡å‹æ¸²æŸ“å®ç°

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/main_camera_pass.cpp:827-950`

```cpp
/**
 * @brief ç»˜åˆ¶æ‰€æœ‰æ¨¡å‹ï¼ˆæ‰¹é‡æ¸²æŸ“ä¼˜åŒ–ï¼‰
 * @param command_buffer å‘½ä»¤ç¼“å†²åŒº
 */
void MainCameraPass::drawModels(RHICommandBuffer* command_buffer) 
{
    // ç»‘å®šæ¨¡å‹æ¸²æŸ“ç®¡çº¿ï¼ˆä¸€æ¬¡ç»‘å®šï¼Œå¤šæ¬¡ä½¿ç”¨ï¼‰
    m_rhi->cmdBindPipelinePFN(command_buffer, RHI_PIPELINE_BIND_POINT_GRAPHICS, 
                             m_render_pipelines[1].graphicsPipeline);
    
    uint32_t currentFrameIndex = m_rhi->getCurrentFrameIndex();
    
    // éå†æ‰€æœ‰æ¨¡å‹è¿›è¡Œæ¸²æŸ“
    for (size_t i = 0; i < m_loaded_render_objects.size(); ++i) {
        const auto& renderObject = m_loaded_render_objects[i];
        
        // è®¡ç®—æ¨¡å‹å˜æ¢çŸ©é˜µ
        glm::mat4 modelMatrix = calculateModelMatrix(renderObject);
        
        // é€šè¿‡Push Constantsä¼ é€’æ¨¡å‹çŸ©é˜µï¼ˆé«˜æ•ˆï¼‰
        m_rhi->cmdPushConstantsPFN(command_buffer, 
                                  m_render_pipelines[1].pipelineLayout,
                                  RHI_SHADER_STAGE_VERTEX_BIT,
                                  0, sizeof(glm::mat4), &modelMatrix);
        
        // ç»‘å®šæè¿°ç¬¦é›†ï¼ˆçº¹ç†å’Œuniform bufferï¼‰
        m_rhi->cmdBindDescriptorSetsPFN(command_buffer, 
                                       RHI_PIPELINE_BIND_POINT_GRAPHICS,
                                       m_render_pipelines[1].pipelineLayout, 
                                       0, 1, &renderObject.descriptorSets[currentFrameIndex], 
                                       0, nullptr);
        
        // ç»‘å®šé¡¶ç‚¹å’Œç´¢å¼•ç¼“å†²åŒº
        RHIBuffer* vertexBuffers[] = {renderObject.vertexBuffer};
        RHIDeviceSize offsets[] = {0};
        m_rhi->cmdBindVertexBuffersPFN(command_buffer, 0, 1, vertexBuffers, offsets);
        m_rhi->cmdBindIndexBufferPFN(command_buffer, renderObject.indexBuffer, 0, RHI_INDEX_TYPE_UINT32);
        
        // æ‰§è¡Œç»˜åˆ¶è°ƒç”¨
        m_rhi->cmdDrawIndexedPFN(command_buffer, 
                                static_cast<uint32_t>(renderObject.indices.size()), 
                                1, 0, 0, 0);
    }
}

/**
 * @brief è®¡ç®—æ¨¡å‹å˜æ¢çŸ©é˜µï¼ˆæ”¯æŒåŠ¨ç”»ï¼‰
 * @param renderObject æ¸²æŸ“å¯¹è±¡
 * @return å˜æ¢çŸ©é˜µ
 */
glm::mat4 MainCameraPass::calculateModelMatrix(const RenderObject& renderObject) 
{
    const auto& params = renderObject.animationParams;
    
    // åŸºç¡€å˜æ¢çŸ©é˜µ
    glm::mat4 translation = glm::translate(glm::mat4(1.0f), params.position);
    glm::mat4 scale = glm::scale(glm::mat4(1.0f), params.scale);
    
    glm::mat4 rotation = glm::mat4(1.0f);
    
    // åŠ¨ç”»æ—‹è½¬è®¡ç®—
    if (params.enableAnimation && !params.isPlatform) {
        float currentTime = getCurrentTime();
        float animatedRotation = currentTime * params.rotationSpeed;
        
        // åº”ç”¨æ—‹è½¬è½´å’Œè§’åº¦
        rotation = glm::rotate(glm::mat4(1.0f), animatedRotation, params.rotationAxis);
    } else {
        // é™æ€æ—‹è½¬
        rotation = glm::rotate(glm::mat4(1.0f), glm::radians(params.rotation.x), glm::vec3(1, 0, 0));
        rotation = glm::rotate(rotation, glm::radians(params.rotation.y), glm::vec3(0, 1, 0));
        rotation = glm::rotate(rotation, glm::radians(params.rotation.z), glm::vec3(0, 0, 1));
    }
    
    // ç»„åˆå˜æ¢çŸ©é˜µï¼šT * R * S
    return translation * rotation * scale;
}
```

---

## 4. æ€§èƒ½ä¼˜åŒ–è¯´æ˜

### 4.1 é˜´å½±è´´å›¾ç”Ÿæˆä¼˜åŒ–ç­–ç•¥

#### é«˜æ•ˆçš„æ·±åº¦æ¸²æŸ“ç®¡çº¿

**ä¼˜åŒ–ç­–ç•¥**:
1. **ç®€åŒ–ç€è‰²å™¨**: é˜´å½±æ¸²æŸ“åªéœ€è¦æ·±åº¦ä¿¡æ¯ï¼Œç‰‡æ®µç€è‰²å™¨ä¸ºç©ºå®ç°
2. **æ—©æœŸæ·±åº¦æµ‹è¯•**: ä½¿ç”¨`layout(early_fragment_tests) in;`ä¼˜åŒ–
3. **èƒŒé¢å‰”é™¤**: å¯ç”¨èƒŒé¢å‰”é™¤å‡å°‘æ¸²æŸ“è´Ÿè½½
4. **32ä½æµ®ç‚¹æ·±åº¦**: ç¡®ä¿é«˜ç²¾åº¦æ·±åº¦æ¯”è¾ƒ

**æ–‡ä»¶ä½ç½®**: `engine/runtime/shader/glsl/mesh_directional_light_shadow.frag`

```glsl
#version 310 es

// å¯ç”¨æ—©æœŸæ·±åº¦æµ‹è¯•ä¼˜åŒ–
layout(early_fragment_tests) in;

void main()
{
    // é˜´å½±æ¸²æŸ“åªéœ€è¦æ·±åº¦ä¿¡æ¯ï¼Œä¸éœ€è¦é¢œè‰²è¾“å‡º
    // æ·±åº¦å€¼ä¼šè‡ªåŠ¨å†™å…¥æ·±åº¦ç¼“å†²åŒº
    // ç‰‡æ®µç€è‰²å™¨å¯ä»¥ä¸ºç©ºï¼Œæˆ–è€…æ‰§è¡Œä¸€äº›æ·±åº¦ç›¸å…³çš„è®¡ç®—
}
```

#### æ‰¹é‡å®ä¾‹æ¸²æŸ“ä¼˜åŒ–

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.cpp:921-1000`

**ä¼˜åŒ–è¦ç‚¹**:
1. **æ‰¹é‡ç¼“å†²åŒºæ›´æ–°**: ä¸€æ¬¡æ€§æ›´æ–°æ‰€æœ‰å®ä¾‹çš„å˜æ¢çŸ©é˜µ
2. **æŒä¹…å†…å­˜æ˜ å°„**: å‡å°‘æ˜ å°„/è§£æ˜ å°„å¼€é”€
3. **GPUæœ¬åœ°å†…å­˜**: ä½¿ç”¨è®¾å¤‡æœ¬åœ°å†…å­˜æé«˜è®¿é—®é€Ÿåº¦

```cpp
/**
 * @brief æ›´æ–°uniform bufferæ•°æ®ï¼ˆæ‰¹é‡ä¼˜åŒ–ï¼‰
 * @details ç¼“å†²åŒºæ›´æ–°ç­–ç•¥ï¼š
 *          1. ğŸ“Š å…¨å±€å¸§ç¼“å†²åŒºæ›´æ–°ï¼šå…‰æºæŠ•å½±è§†å›¾çŸ©é˜µ
 *          2. ğŸ¨ å®ä¾‹æ•°æ®ç¼“å†²åŒºæ›´æ–°ï¼šæ‰€æœ‰æ¨¡å‹å˜æ¢çŸ©é˜µ
 *          3. ğŸ”— æè¿°ç¬¦é›†ç»‘å®šä¼˜åŒ–ï¼šé¿å…é‡å¤ç»‘å®š
 */
void DirectionalLightShadowPass::updateUniformBuffer()
{
    if (!m_current_render_resource) {
        LOG_ERROR("[DirectionalLightShadowPass] Current render resource is null");
        return;
    }
    
    std::shared_ptr<RHI> rhi = g_runtime_global_context.m_render_system->getRHI();
    
    // 1. æ›´æ–°å…¨å±€å¸§ç¼“å†²åŒºï¼ˆå…‰æºçŸ©é˜µï¼‰
    void* global_data;
    rhi->mapMemory(m_global_uniform_buffer_memory, 0, sizeof(glm::mat4), 0, &global_data);
    memcpy(global_data, &m_light_proj_view_matrix, sizeof(glm::mat4));
    rhi->unmapMemory(m_global_uniform_buffer_memory);
    
    // 2. æ‰¹é‡æ›´æ–°å®ä¾‹æ•°æ®ç¼“å†²åŒº
    const auto& render_objects = m_current_render_resource->m_RenderObjects;
    size_t instance_count = render_objects.size();
    
    if (instance_count > 0) {
        // è®¡ç®—æ‰€éœ€ç¼“å†²åŒºå¤§å°
        size_t buffer_size = instance_count * sizeof(glm::mat4);
        
        // æ£€æŸ¥ç¼“å†²åŒºå®¹é‡ï¼Œå¿…è¦æ—¶é‡æ–°åˆ†é…
        if (m_instance_buffer_size < buffer_size) {
            // é‡æ–°åˆ›å»ºæ›´å¤§çš„ç¼“å†²åŒº
            recreateInstanceBuffer(buffer_size);
        }
        
        // æ‰¹é‡æ›´æ–°å®ä¾‹çŸ©é˜µ
        void* instance_data;
        rhi->mapMemory(m_instance_uniform_buffer_memory, 0, buffer_size, 0, &instance_data);
        
        glm::mat4* matrices = static_cast<glm::mat4*>(instance_data);
        for (size_t i = 0; i < instance_count; ++i) {
            matrices[i] = calculateModelMatrix(render_objects[i]);
        }
        
        rhi->unmapMemory(m_instance_uniform_buffer_memory);
        
        LOG_DEBUG("[DirectionalLightShadowPass] Updated {} instance matrices", instance_count);
    }
}
```

### 4.2 å…‰ç…§è®¡ç®—æ€§èƒ½ä¼˜åŒ–æŠ€å·§

#### BRDFè®¡ç®—ä¼˜åŒ–

**ä¼˜åŒ–ç­–ç•¥**:
1. **é¢„è®¡ç®—æŸ¥æ‰¾è¡¨**: ä½¿ç”¨BRDF LUTå‡å°‘å®æ—¶è®¡ç®—
2. **è¿‘ä¼¼ç®—æ³•**: ä½¿ç”¨Schlickè¿‘ä¼¼æ›¿ä»£ç²¾ç¡®è®¡ç®—
3. **å‘é‡åŒ–æ“ä½œ**: åˆ©ç”¨GPUå¹¶è¡Œè®¡ç®—èƒ½åŠ›

**æ–‡ä»¶ä½ç½®**: `engine/runtime/shader/include/mesh_lighting.h:20-80`

```glsl
/**
 * @brief ä¼˜åŒ–çš„Schlickè²æ¶…å°”è¿‘ä¼¼
 * @param cosTheta è§†è§’ä¸æ³•çº¿å¤¹è§’ä½™å¼¦å€¼
 * @param F0 æè´¨çš„åŸºç¡€åå°„ç‡
 * @return è²æ¶…å°”åå°„ç³»æ•°
 */
highp vec3 F_Schlick(highp float cosTheta, highp vec3 F0) 
{ 
    // ä½¿ç”¨å¿«é€Ÿå¹‚è¿ç®—ä¼˜åŒ–
    return F0 + (1.0 - F0) * Pow5(1.0 - cosTheta); 
}

/**
 * @brief å¿«é€Ÿ5æ¬¡å¹‚è®¡ç®—ï¼ˆé¿å…powå‡½æ•°è°ƒç”¨ï¼‰
 */
highp float Pow5(highp float x)
{
    return (x * x * x * x * x);
}

/**
 * @brief ä¼˜åŒ–çš„Smithå‡ ä½•é®è”½å‡½æ•°
 * @details ä½¿ç”¨ç›¸å…³æ€§Smith Gå‡½æ•°ï¼Œæ¯”åˆ†ç¦»ç‰ˆæœ¬æ›´ç²¾ç¡®ä¸”é«˜æ•ˆ
 */
highp float G_SchlicksmithGGX(highp float dotNL, highp float dotNV, highp float roughness)
{
    highp float r = (roughness + 1.0);
    highp float k = (r * r) / 8.0;  // ç›´æ¥å…‰ç…§çš„kå€¼
    highp float GL = dotNL / (dotNL * (1.0 - k) + k);
    highp float GV = dotNV / (dotNV * (1.0 - k) + k);
    return GL * GV;
}
```

#### é˜´å½±é‡‡æ ·ä¼˜åŒ–

**PCFä¼˜åŒ–å®ç°**:

```glsl
/**
 * @brief ä¼˜åŒ–çš„PCFé˜´å½±é‡‡æ ·
 * @details ä½¿ç”¨å›ºå®šé‡‡æ ·æ¨¡å¼å’Œçº¹ç†ç¼“å­˜ä¼˜åŒ–
 */
float calculateShadowPCF(vec4 fragPosLightSpace)
{
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    projCoords = projCoords * 0.5 + 0.5;
    
    // è¾¹ç•Œæ£€æŸ¥ä¼˜åŒ–
    if (any(lessThan(projCoords.xy, vec2(0.0))) || 
        any(greaterThan(projCoords.xy, vec2(1.0))) || 
        projCoords.z > 1.0) {
        return 1.0;
    }
    
    float currentDepth = projCoords.z;
    float bias = 0.005;
    
    // ä¼˜åŒ–çš„3x3 PCFé‡‡æ ·
    float shadow = 0.0;
    vec2 texelSize = 1.0 / textureSize(directional_light_shadow, 0);
    
    // å±•å¼€å¾ªç¯ä»¥æé«˜æ€§èƒ½
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2(-1, -1)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2(-1,  0)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2(-1,  1)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2( 0, -1)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2( 0,  0)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2( 0,  1)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2( 1, -1)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2( 1,  0)).r) ? 1.0 : 0.0;
    shadow += (currentDepth - bias > textureOffset(directional_light_shadow, projCoords.xy, ivec2( 1,  1)).r) ? 1.0 : 0.0;
    
    return 1.0 - (shadow / 9.0);
}
```

### 4.3 åœºæ™¯æ¸²æŸ“æ‰¹å¤„ç†å®ç°

#### GPUèµ„æºç®¡ç†ä¼˜åŒ–

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/render_resource.cpp:485-550`

**ä¼˜åŒ–ç­–ç•¥**:
1. **æš‚å­˜ç¼“å†²åŒº**: ä½¿ç”¨æš‚å­˜ç¼“å†²åŒºä¼˜åŒ–GPUå†…å­˜ä¼ è¾“
2. **è®¾å¤‡æœ¬åœ°å†…å­˜**: çº¹ç†å’Œç¼“å†²åŒºä½¿ç”¨GPUæœ¬åœ°å†…å­˜
3. **æ‰¹é‡èµ„æºåˆ›å»º**: å‡å°‘APIè°ƒç”¨æ¬¡æ•°

```cpp
/**
 * @brief ä¼˜åŒ–çš„çº¹ç†åˆ›å»ºæµç¨‹
 * @details GPUå†…å­˜ä¼ è¾“ä¼˜åŒ–ï¼š
 *          1. åˆ›å»ºæš‚å­˜ç¼“å†²åŒºï¼ˆCPUå¯è®¿é—®ï¼‰
 *          2. åˆ›å»ºç›®æ ‡å›¾åƒï¼ˆGPUæœ¬åœ°å†…å­˜ï¼‰
 *          3. æ‰§è¡ŒGPUæ‹·è´å‘½ä»¤
 *          4. æ¸…ç†æš‚å­˜èµ„æº
 */
bool RenderResource::createTextureFromFile(const std::string& filename, 
                                          RenderObject& renderObject, 
                                          size_t index)
{
    // 1. åŠ è½½å›¾åƒæ•°æ®
    int texWidth, texHeight, texChannels;
    stbi_uc* pixels = stbi_load(filename.c_str(), &texWidth, &texHeight, &texChannels, STBI_rgb_alpha);
    
    if (!pixels) {
        LOG_ERROR("Failed to load texture: {}", filename);
        return false;
    }
    
    RHIDeviceSize imageSize = texWidth * texHeight * 4; // RGBA
    
    // 2. åˆ›å»ºæš‚å­˜ç¼“å†²åŒºï¼ˆCPUå¯è®¿é—®ï¼‰
    RHIBuffer* stagingBuffer;
    RHIDeviceMemory* stagingBufferMemory;
    m_rhi->createBuffer(imageSize, 
                       RHI_BUFFER_USAGE_TRANSFER_SRC_BIT,
                       RHI_MEMORY_PROPERTY_HOST_VISIBLE_BIT | RHI_MEMORY_PROPERTY_HOST_COHERENT_BIT,
                       stagingBuffer, stagingBufferMemory);
    
    // 3. æ‹·è´å›¾åƒæ•°æ®åˆ°æš‚å­˜ç¼“å†²åŒº
    void* data;
    m_rhi->mapMemory(stagingBufferMemory, 0, imageSize, 0, &data);
    memcpy(data, pixels, static_cast<size_t>(imageSize));
    m_rhi->unmapMemory(stagingBufferMemory);
    
    stbi_image_free(pixels);
    
    // 4. åˆ›å»ºGPUæœ¬åœ°å›¾åƒ
    m_rhi->createImage(texWidth, texHeight, 
                      RHI_FORMAT_R8G8B8A8_SRGB,
                      RHI_IMAGE_TILING_OPTIMAL,
                      RHI_IMAGE_USAGE_TRANSFER_DST_BIT | RHI_IMAGE_USAGE_SAMPLED_BIT,
                      RHI_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                      renderObject.textureImages[index],
                      renderObject.textureImageMemorys[index],
                      0, 1, 1);
    
    // 5. æ‰§è¡Œå›¾åƒå¸ƒå±€è½¬æ¢å’Œæ•°æ®æ‹·è´
    transitionImageLayout(renderObject.textureImages[index], 
                         RHI_FORMAT_R8G8B8A8_SRGB,
                         RHI_IMAGE_LAYOUT_UNDEFINED, 
                         RHI_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
    
    copyBufferToImage(stagingBuffer, renderObject.textureImages[index], 
                     static_cast<uint32_t>(texWidth), 
                     static_cast<uint32_t>(texHeight));
    
    transitionImageLayout(renderObject.textureImages[index], 
                         RHI_FORMAT_R8G8B8A8_SRGB,
                         RHI_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 
                         RHI_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL);
    
    // 6. æ¸…ç†æš‚å­˜èµ„æº
    m_rhi->destroyBuffer(stagingBuffer);
    m_rhi->freeMemory(stagingBufferMemory);
    
    return true;
}
```

#### æ¸²æŸ“çŠ¶æ€ç¼“å­˜ä¼˜åŒ–

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/main_camera_pass.cpp:750-820`

**ä¼˜åŒ–è¦ç‚¹**:
1. **çŠ¶æ€ç¼“å­˜**: é¿å…é‡å¤çš„ç®¡çº¿å’Œæè¿°ç¬¦ç»‘å®š
2. **æ‰¹é‡ç»˜åˆ¶**: ç›¸åŒæè´¨çš„å¯¹è±¡æ‰¹é‡æ¸²æŸ“
3. **å®ä¾‹åŒ–æ¸²æŸ“**: ç›¸åŒå‡ ä½•ä½“çš„å¤šå®ä¾‹æ¸²æŸ“

```cpp
/**
 * @brief çŠ¶æ€ç¼“å­˜ä¼˜åŒ–çš„æ¸²æŸ“å¾ªç¯
 */
void MainCameraPass::drawModelsOptimized(RHICommandBuffer* command_buffer)
{
    // çŠ¶æ€ç¼“å­˜å˜é‡
    RHIPipeline* currentPipeline = nullptr;
    RHIDescriptorSet* currentDescriptorSet = nullptr;
    RHIBuffer* currentVertexBuffer = nullptr;
    RHIBuffer* currentIndexBuffer = nullptr;
    
    uint32_t currentFrameIndex = m_rhi->getCurrentFrameIndex();
    
    // æŒ‰æè´¨åˆ†ç»„æ¸²æŸ“å¯¹è±¡ï¼ˆå‡å°‘çŠ¶æ€åˆ‡æ¢ï¼‰
    auto groupedObjects = groupRenderObjectsByMaterial(m_loaded_render_objects);
    
    for (const auto& [materialId, objects] : groupedObjects) {
        // ç»‘å®šæè´¨ç›¸å…³çš„ç®¡çº¿ï¼ˆåªåœ¨æè´¨åˆ‡æ¢æ—¶ç»‘å®šï¼‰
        if (currentPipeline != m_render_pipelines[materialId].graphicsPipeline) {
            currentPipeline = m_render_pipelines[materialId].graphicsPipeline;
            m_rhi->cmdBindPipelinePFN(command_buffer, RHI_PIPELINE_BIND_POINT_GRAPHICS, currentPipeline);
        }
        
        // æ‰¹é‡æ¸²æŸ“ç›¸åŒæè´¨çš„å¯¹è±¡
        for (const auto& renderObject : objects) {
            // åªåœ¨ç¼“å†²åŒºå˜åŒ–æ—¶é‡æ–°ç»‘å®š
            if (currentVertexBuffer != renderObject.vertexBuffer) {
                currentVertexBuffer = renderObject.vertexBuffer;
                RHIBuffer* vertexBuffers[] = {currentVertexBuffer};
                RHIDeviceSize offsets[] = {0};
                m_rhi->cmdBindVertexBuffersPFN(command_buffer, 0, 1, vertexBuffers, offsets);
            }
            
            if (currentIndexBuffer != renderObject.indexBuffer) {
                currentIndexBuffer = renderObject.indexBuffer;
                m_rhi->cmdBindIndexBufferPFN(command_buffer, currentIndexBuffer, 0, RHI_INDEX_TYPE_UINT32);
            }
            
            // æ›´æ–°æ¨¡å‹çŸ©é˜µ
            glm::mat4 modelMatrix = calculateModelMatrix(renderObject);
            m_rhi->cmdPushConstantsPFN(command_buffer, 
                                      m_render_pipelines[materialId].pipelineLayout,
                                      RHI_SHADER_STAGE_VERTEX_BIT,
                                      0, sizeof(glm::mat4), &modelMatrix);
            
            // ç»‘å®šæè¿°ç¬¦é›†ï¼ˆåªåœ¨å˜åŒ–æ—¶ç»‘å®šï¼‰
            if (currentDescriptorSet != renderObject.descriptorSets[currentFrameIndex]) {
                currentDescriptorSet = renderObject.descriptorSets[currentFrameIndex];
                m_rhi->cmdBindDescriptorSetsPFN(command_buffer, 
                                               RHI_PIPELINE_BIND_POINT_GRAPHICS,
                                               m_render_pipelines[materialId].pipelineLayout, 
                                               0, 1, &currentDescriptorSet, 0, nullptr);
            }
            
            // æ‰§è¡Œç»˜åˆ¶
            m_rhi->cmdDrawIndexedPFN(command_buffer, 
                                    static_cast<uint32_t>(renderObject.indices.size()), 
                                    1, 0, 0, 0);
        }
    }
}
```

---

## 5. æ•°å­¦å…¬å¼å’Œç®—æ³•

### 5.1 é˜´å½±æŠ•å½±æ•°å­¦åŸç†

#### æ­£äº¤æŠ•å½±çŸ©é˜µ

é˜´å½±è´´å›¾ä½¿ç”¨æ­£äº¤æŠ•å½±ï¼Œæ•°å­¦å…¬å¼ä¸ºï¼š

$$P_{ortho} = \begin{bmatrix}
\frac{2}{r-l} & 0 & 0 & -\frac{r+l}{r-l} \\
0 & \frac{2}{t-b} & 0 & -\frac{t+b}{t-b} \\
0 & 0 & -\frac{2}{f-n} & -\frac{f+n}{f-n} \\
0 & 0 & 0 & 1
\end{bmatrix}$$

å…¶ä¸­ï¼š
- `l, r`: å·¦å³è¾¹ç•Œ (-50.0, 50.0)
- `b, t`: ä¸‹ä¸Šè¾¹ç•Œ (-50.0, 50.0)  
- `n, f`: è¿‘è¿œå¹³é¢ (0.1, 150.0)

#### å…‰æºè§†å›¾çŸ©é˜µ

å…‰æºè§†å›¾çŸ©é˜µä½¿ç”¨LookAtå˜æ¢ï¼š

$$V_{light} = LookAt(eye, center, up)$$

å…¶ä¸­ï¼š
- `eye`: å…‰æºä½ç½® = -lightDirection Ã— 50.0
- `center`: åœºæ™¯ä¸­å¿ƒ (0, 0, 0)
- `up`: ä¸Šæ–¹å‘ (0, 1, 0)

#### é˜´å½±åæ ‡å˜æ¢

ä»ä¸–ç•Œåæ ‡åˆ°é˜´å½±è´´å›¾åæ ‡çš„å®Œæ•´å˜æ¢ï¼š

$$P_{shadow} = P_{ortho} \times V_{light} \times P_{world}$$

$$UV_{shadow} = \frac{P_{shadow}.xy}{P_{shadow}.w} \times 0.5 + 0.5$$

### 5.2 PBRå…‰ç…§æ•°å­¦æ¨¡å‹

#### æ¸²æŸ“æ–¹ç¨‹

PBRåŸºäºç‰©ç†çš„æ¸²æŸ“æ–¹ç¨‹ï¼š

$$L_o(p,\omega_o) = \int_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) n \cdot \omega_i d\omega_i$$

#### BRDFåˆ†è§£

åŒå‘åå°„åˆ†å¸ƒå‡½æ•°åˆ†è§£ä¸ºæ¼«åå°„å’Œé•œé¢åå°„ï¼š

$$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$$

å…¶ä¸­ï¼š
- $k_d = (1-F)(1-metallic)$ : æ¼«åå°„ç³»æ•°
- $k_s = F$ : é•œé¢åå°„ç³»æ•°

#### Cook-Torrance BRDF

$$f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}$$

**æ³•çº¿åˆ†å¸ƒå‡½æ•° (GGX)**:
$$D_{GGX}(n,h,\alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2(\alpha^2-1)+1)^2}$$

**å‡ ä½•å‡½æ•° (Smith)**:
$$G_{Smith}(n,v,l,k) = G_1(n,v,k)G_1(n,l,k)$$
$$G_1(n,v,k) = \frac{n \cdot v}{(n \cdot v)(1-k)+k}$$

**è²æ¶…å°”å‡½æ•° (Schlickè¿‘ä¼¼)**:
$$F_{Schlick}(h,v,F_0) = F_0 + (1-F_0)(1-(h \cdot v))^5$$

---

## 6. ç³»ç»Ÿé›†æˆè¯´æ˜

### 6.1 æ¸²æŸ“ç®¡çº¿é›†æˆ

#### æ¸²æŸ“é€šé“æ‰§è¡Œé¡ºåº

```mermaid
sequenceDiagram
    participant App as Application
    participant RP as RenderPipeline  
    participant DSP as DirectionalShadowPass
    participant MCP as MainCameraPass
    participant UI as UIPass
    
    App->>RP: beginFrame()
    RP->>DSP: initialize()
    RP->>DSP: draw() [é˜´å½±è´´å›¾ç”Ÿæˆ]
    DSP-->>RP: é˜´å½±è´´å›¾å®Œæˆ
    
    RP->>MCP: initialize()
    RP->>MCP: draw() [ä¸»åœºæ™¯æ¸²æŸ“]
    MCP->>MCP: ç»‘å®šé˜´å½±è´´å›¾
    MCP->>MCP: æ‰§è¡Œå…‰ç…§è®¡ç®—
    MCP-->>RP: ä¸»åœºæ™¯å®Œæˆ
    
    RP->>UI: draw() [UIæ¸²æŸ“]
    UI-->>RP: UIæ¸²æŸ“å®Œæˆ
    
    RP->>App: endFrame()
```

### 6.2 èµ„æºåŒæ­¥æœºåˆ¶

#### GPUåŒæ­¥ç‚¹

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/render_pipeline.cpp:120-180`

```cpp
/**
 * @brief æ¸²æŸ“é€šé“é—´çš„åŒæ­¥æœºåˆ¶
 */
void RenderPipeline::executeRenderPasses()
{
    // 1. é˜´å½±æ¸²æŸ“é€šé“
    m_directional_light_shadow_pass->draw();
    
    // 2. å†…å­˜å±éšœï¼šç¡®ä¿é˜´å½±è´´å›¾å†™å…¥å®Œæˆ
    RHIMemoryBarrier barrier{};
    barrier.sType = RHI_STRUCTURE_TYPE_MEMORY_BARRIER;
    barrier.srcAccessMask = RHI_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT;
    barrier.dstAccessMask = RHI_ACCESS_SHADER_READ_BIT;
    
    m_rhi->cmdPipelineBarrier(
        m_command_buffers[m_current_frame_index],
        RHI_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT,
        RHI_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,
        0, 1, &barrier, 0, nullptr, 0, nullptr
    );
    
    // 3. ä¸»ç›¸æœºæ¸²æŸ“é€šé“ï¼ˆä½¿ç”¨é˜´å½±è´´å›¾ï¼‰
    m_main_camera_pass->draw();
}
```

### 6.3 é”™è¯¯å¤„ç†å’Œè°ƒè¯•

#### è°ƒè¯•ä¿¡æ¯è¾“å‡º

**æ–‡ä»¶ä½ç½®**: `engine/runtime/render/passes/directional_light_pass.cpp:875-920`

```cpp
/**
 * @brief å…‰æºå‚æ•°éªŒè¯å’Œè°ƒè¯•è¾“å‡º
 */
void DirectionalLightShadowPass::validateLightParameters()
{
    // å…‰æºæ–¹å‘éªŒè¯
    float dirLength = glm::length(lightDirection);
    if (dirLength < 0.1f) {
        LOG_ERROR("Light direction too small: {:.6f}", dirLength);
    }
    
    // æŠ•å½±çŸ©é˜µéªŒè¯
    float determinant = glm::determinant(m_light_proj_view_matrix);
    if (abs(determinant) < 1e-6) {
        LOG_ERROR("Light projection-view matrix is singular! Determinant: {:.6f}", determinant);
    }
    
    // é˜´å½±è´´å›¾èŒƒå›´éªŒè¯
    LOG_DEBUG("Shadow map coverage: [{:.1f}, {:.1f}] x [{:.1f}, {:.1f}]", 
              -ortho_size, ortho_size, -ortho_size, ortho_size);
    
    // æ·±åº¦èŒƒå›´éªŒè¯
    LOG_DEBUG("Depth range: [{:.1f}, {:.1f}]", near_plane, far_plane);
}
```

---

## æ€»ç»“

æœ¬æŠ€æœ¯æ–‡æ¡£è¯¦ç»†ä»‹ç»äº†EnumaElishå¼•æ“çš„é˜´å½±å…‰ç…§å’Œåœºæ™¯ç³»ç»Ÿå®ç°ã€‚ç³»ç»Ÿé‡‡ç”¨ç°ä»£åŒ–çš„PBRæ¸²æŸ“ç®¡çº¿ï¼Œç»“åˆé«˜æ•ˆçš„é˜´å½±è´´å›¾æŠ€æœ¯ï¼Œå®ç°äº†é«˜è´¨é‡çš„å®æ—¶æ¸²æŸ“æ•ˆæœã€‚

### ä¸»è¦ç‰¹æ€§

1. **ğŸŒŸ é«˜è´¨é‡é˜´å½±**: 2048Ã—2048åˆ†è¾¨ç‡ï¼Œ32ä½æµ®ç‚¹ç²¾åº¦
2. **âš¡ æ€§èƒ½ä¼˜åŒ–**: æ‰¹é‡æ¸²æŸ“ã€çŠ¶æ€ç¼“å­˜ã€GPUæœ¬åœ°å†…å­˜
3. **ğŸ¨ PBRå…‰ç…§**: åŸºäºç‰©ç†çš„æè´¨å’Œå…‰ç…§æ¨¡å‹
4. **ğŸ”§ çµæ´»é…ç½®**: JSONé©±åŠ¨çš„åœºæ™¯é…ç½®ç³»ç»Ÿ
5. **ğŸ› è°ƒè¯•å‹å¥½**: å®Œå–„çš„æ—¥å¿—å’Œå‚æ•°éªŒè¯

### æŠ€æœ¯äº®ç‚¹

- **ç°ä»£å›¾å½¢API**: åŸºäºVulkançš„RHIæŠ½è±¡å±‚
- **æ•°å­¦ç²¾ç¡®æ€§**: ä¸¥æ ¼çš„æ•°å­¦å…¬å¼å®ç°
- **å†…å­˜æ•ˆç‡**: ä¼˜åŒ–çš„GPUèµ„æºç®¡ç†
- **å¯æ‰©å±•æ€§**: æ¨¡å—åŒ–çš„æ¸²æŸ“é€šé“è®¾è®¡

è¯¥ç³»ç»Ÿä¸ºå®æ—¶3Dåº”ç”¨æä¾›äº†åšå®çš„æ¸²æŸ“åŸºç¡€ï¼Œæ”¯æŒå¤æ‚åœºæ™¯çš„é«˜æ•ˆæ¸²æŸ“ã€‚