#version 450

// ============================================================================
// 网格渲染片段着色器
// ============================================================================
/**
 * @file mesh.frag
 * @brief 基础网格渲染片段着色器，支持纹理采样和阴影计算
 * @details 实现基本的纹理混合和方向光阴影映射
 *          
 *          渲染流程：
 *          1. 采样漫反射纹理和细节纹理
 *          2. 计算阴影因子（使用PCF软阴影）
 *          3. 应用阴影到最终颜色输出
 *          
 *          阴影映射技术：
 *          - 使用方向光的阴影贴图
 *          - 实现PCF（百分比渐进过滤）软阴影
 *          - 包含阴影失真修正和边界处理
 */

// ============================================================================
// 推送常量（已注释）
// ============================================================================
// 全局时间常量，可用于动画效果
// layout( push_constant ) uniform constants
// {
// 	float time;  // 全局时间，用于动画和特效
// } global;

// ============================================================================
// 纹理采样器
// ============================================================================
/**
 * @brief 纹理采样器绑定
 * @details 绑定到描述符集合的不同位置
 */
layout(set = 0, binding = 1) uniform sampler2D sampler1; // 主纹理（漫反射贴图）
layout(set = 0, binding = 2) uniform sampler2D sampler2; // 细节纹理（法线贴图或细节贴图）
layout(set = 0, binding = 8) uniform sampler2D directional_light_shadow; // 方向光阴影贴图

// ============================================================================
// 片段着色器输入
// ============================================================================
/**
 * @brief 从顶点着色器传入的插值数据
 */
layout(location = 0) in vec3 fragColor;        // 顶点颜色（插值后）
layout(location = 1) in vec2 fragTexCoord;     // 纹理坐标（插值后）
layout(location = 2) in vec4 fragPosLightSpace; // 光源空间坐标（用于阴影计算）

// ============================================================================
// 片段着色器输出
// ============================================================================
/**
 * @brief 最终颜色输出
 */
layout(location = 0) out vec4 outColor;  // RGBA颜色输出到帧缓冲区

// ============================================================================
// 阴影计算函数
// ============================================================================
/**
 * @brief 计算阴影因子（使用PCF软阴影技术）
 * @param fragPosLightSpace 片段在光源空间的坐标
 * @return 阴影因子，0.0表示完全在阴影中，1.0表示完全被照亮
 * 
 * @details 阴影映射算法流程：
 *          1. 坐标变换：光源空间 -> NDC空间 -> 纹理空间
 *          2. 深度比较：当前深度 vs 阴影贴图深度
 *          3. PCF过滤：多点采样平滑阴影边缘
 *          4. 边界处理：超出阴影贴图范围的处理
 *          
 *          PCF（百分比渐进过滤）原理：
 *          - 在阴影贴图上进行多点采样
 *          - 对每个采样点进行深度比较
 *          - 计算被遮挡采样点的百分比
 *          - 实现软阴影效果，消除锯齿边缘
 */
float calculateShadow(vec4 fragPosLightSpace)
{
    // ========================================================================
    // 第一步：坐标空间变换
    // ========================================================================
    
    // 执行透视除法，将齐次坐标转换为NDC坐标
    // NDC坐标范围：[-1, 1] (Vulkan标准)
    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;
    
    // 将NDC坐标从[-1,1]范围转换到[0,1]范围以匹配纹理坐标
    // 变换公式：uv = (ndc + 1.0) * 0.5
    projCoords = projCoords * 0.5 + 0.5;
    
    // ========================================================================
    // 第二步：边界检查
    // ========================================================================
    
    // 如果投影坐标超出阴影贴图范围，则认为不在阴影中
    // 这处理了光源视锥体外的区域
    if (projCoords.z > 1.0 || projCoords.x < 0.0 || projCoords.x > 1.0 || 
        projCoords.y < 0.0 || projCoords.y > 1.0) {
        return 1.0;  // 完全照亮
    }
    
    // ========================================================================
    // 第三步：深度采样和比较
    // ========================================================================
    
    // 从阴影贴图中采样最近的深度值
    // 这是从光源视角看到的最近表面深度
    float closestDepth = texture(directional_light_shadow, projCoords.xy).r;
    
    // 获取当前片段在光空间中的深度
    // 这是当前片段到光源的距离
    float currentDepth = projCoords.z;
    
    // ========================================================================
    // 第四步：阴影失真修正
    // ========================================================================
    
    // 添加深度偏置以减少阴影失真（shadow acne）
    // 阴影失真产生原因：
    // 1. 深度缓冲区精度限制
    // 2. 表面法向量与光线方向的夹角
    // 3. 阴影贴图分辨率限制
    float bias = 0.005;
    
    // ========================================================================
    // 第五步：PCF软阴影实现
    // ========================================================================
    
    // PCF (Percentage Closer Filtering) 软阴影实现
    // 通过多点采样平滑阴影边缘，消除锯齿效果
    float shadow = 0.0;
    
    // 计算纹理像素大小，用于偏移采样坐标
    vec2 texelSize = 1.0 / textureSize(directional_light_shadow, 0);
    
    // 3x3 PCF采样核心
    // 在当前像素周围进行9点采样
    for(int x = -1; x <= 1; ++x)
    {
        for(int y = -1; y <= 1; ++y)
        {
            // 计算偏移后的采样坐标
            vec2 offset = vec2(x, y) * texelSize;
            
            // 采样阴影贴图深度值
            float pcfDepth = texture(directional_light_shadow, projCoords.xy + offset).r;
            
            // 深度比较：如果当前深度大于存储深度（考虑偏置），则在阴影中
            // 使用三元运算符进行二进制判断：阴影=1.0，非阴影=0.0
            shadow += currentDepth - bias > pcfDepth ? 1.0 : 0.0;
        }
    }
    
    // 计算平均阴影值（9个采样点的平均）
    // 结果范围：[0.0, 1.0]
    // 0.0 = 完全照亮，1.0 = 完全遮挡
    shadow /= 9.0;
    
    // ========================================================================
    // 第六步：返回光照因子
    // ========================================================================
    
    // 返回光照因子（1.0 - shadow）
    // 光照因子范围：[0.0, 1.0]
    // 0.0 = 完全在阴影中，1.0 = 完全被照亮
    return 1.0 - shadow;
}

// ============================================================================
// 主函数 - 片段渲染
// ============================================================================
/**
 * @brief 片段着色器主函数
 * @details 执行纹理采样、阴影计算和最终颜色合成
 *          
 *          渲染管线流程：
 *          1. 纹理采样：获取表面材质信息
 *          2. 阴影计算：计算光照遮挡情况
 *          3. 光照应用：结合环境光和直接光照
 *          4. 颜色合成：输出最终像素颜色
 *          
 *          颜色计算公式：
 *          FinalColor = VertexColor × (DiffuseTexture × DetailTexture × 2.0) × LightingFactor
 */
void main()
{
    // ========================================================================
    // 第一步：纹理采样
    // ========================================================================
    
    // 采样主纹理（漫反射贴图）
    // 通常包含物体的基础颜色信息
    vec3 c = texture(sampler1, fragTexCoord).rgb;
    
    // 采样细节纹理（可能是法线贴图、细节贴图或其他材质贴图）
    // 用于增强表面细节和材质质感
    vec3 o = texture(sampler2, fragTexCoord).rgb;
    
    // ========================================================================
    // 第二步：阴影计算
    // ========================================================================
    
    // 计算阴影因子（使用PCF软阴影技术）
    // 返回值范围：[0.0, 1.0]
    // 0.0 = 完全在阴影中，1.0 = 完全被照亮
    float shadow = calculateShadow(fragPosLightSpace);
    
    // ========================================================================
    // 第三步：光照模型应用
    // ========================================================================
    
    // 应用阴影到最终颜色
    // 确保即使在阴影中也有一定的环境光照
    // 这模拟了现实中的间接光照和环境光散射
    float ambientStrength = 0.3;  // 环境光强度（30%）
    
    // 光照因子 = max(阴影因子, 环境光强度)
    // 确保最暗区域仍有基础可见度
    shadow = max(shadow, ambientStrength);
    
    // ========================================================================
    // 第四步：最终颜色合成
    // ========================================================================
    
    // 最终颜色计算：
    // 1. fragColor：顶点颜色（来自顶点着色器插值）
    // 2. c × o × 2.0：纹理混合（主纹理 × 细节纹理 × 增强系数）
    // 3. shadow：光照因子（包含阴影和环境光）
    // 4. 1.0：完全不透明的Alpha值
    outColor = vec4(fragColor * (c * o * 2.0) * shadow, 1.0);
    
    // 颜色分量说明：
    // - RGB：最终可见颜色
    // - A：透明度（1.0表示完全不透明）
}
